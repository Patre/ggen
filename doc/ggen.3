.TH GGEN 3 "" "GGen Library Manual"
.SH NAME
.PP
ggen \- graph generation library
.SH SYNOPSIS
.IP
.nf
\f[C]
#include<ggen.h>
igraph_t\ *ggen_generate_erdos_gnm(gsl_rng\ *r,\ unsigned\ long\ n,\ unsigned\ long\ m);
igraph_t\ *ggen_generate_erdos_gnp(gsl_rng\ *r,\ unsigned\ long\ n,\ double\ p);
igraph_t\ *ggen_generate_erdos_lbl(gsl_rng\ *r,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unsigned\ long\ n,\ double\ p,\ unsigned\ long\ nbl);

igraph_t\ *ggen_generate_fifo(gsl_rng\ *r,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unsigned\ long\ n,\ unsigned\ long\ od,\ unsigned\ long\ id);

igraph_t\ *ggen_generate_random_orders(gsl_rng\ *r,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unsigned\ long\ n,\ unsigned\ int\ orders);

igraph_vector_t\ *\ ggen_analyze_longest_path(igraph_t\ *g);
igraph_vector_t\ *\ ggen_analyze_longest_antichain(igraph_t\ *g);
igraph_vector_t\ *\ ggen_analyze_lowest_single_ancestor(igraph_t\ *g);

enum\ ggen_transform_t\ {\ GGEN_TRANSFORM_SOURCE,\ GGEN_TRANSFORM_SINK\ };
int\ ggen_transform_add(igraph_t\ *g,\ enum\ ggen_transform_t\ t);
int\ ggen_transform_delete(igraph_t\ *g,\ enum\ ggen_transform_t\ t);
\f[]
.fi
.SH DESCRIPTION
.PP
The GGen library provides an implementation of several random dag
generators used in scheduling research.
Along with these generators, a collection of analysis and utility
fonctions are provided.
.PP
The graph data structure comes from the
Igraph (http://igraph.sourceforge.net) library.
Random Number Generators come from
GSL (http://www.gnu.org/software/gsl).
.SS Generation Functions
.PP
All generation function take as argument a random number generator
\f[I]r\f[] from GSL.
This generator must be initialized before the function call.
.IP \[bu] 2
\f[C]ggen_generate_erdos_gnm()\f[]
.RS 2
.PP
Generates a DAG having \f[I]n\f[] nodes and \f[I]m\f[] edges.
Edges are selected all at once among all the possible edges of a DAG.
.PP
This is very similar to the \f[I]G(n,m)\f[] random graph model but only
edges that are valid in a DAG are taken into account.
.RE
.IP \[bu] 2
\f[C]ggen_generate_erdos_gnp()\f[]
.RS 2
.PP
Generates a DAG having \f[I]n\f[] nodes.
Each possible edges of the DAG is tested for inclusion (with a
\f[I]Bernouilli trial\f[]) with probability \f[I]p\f[].
.PP
This is very similar to the \f[I]G(n,p)\f[] random graph model but,
again, only edges valid in a DAG are taken into account.
.RE
.IP \[bu] 2
\f[C]ggen_generate_erdos_lbl()\f[]
.RS 2
.PP
Generates a DAG having \f[I]n\f[] nodes and \f[I]nbl\f[] levels.
A level is defined as a group of nodes that cannot share an edge.
Nodes are dispatched uniformly inside \f[I]nbl\f[] levels before
applying the \f[I]erdos G(n,p)\f[] algorithm with probability
\f[I]p\f[].
.RE
.IP \[bu] 2
\f[C]ggen_generate_fifo()\f[]
.RS 2
.PP
Generates a DAG having at least \f[I]n\f[] nodes using a
\f[I]Fan\-in/Fan\-out\f[] algorithm.
Starting with a single node, this function alternates (with equal
probability) between \f[I]expansion\f[] phases where new nodes are added
to a node having few outgoing edges, and \f[I]contraction\f[] phases
where a random number of heavy nodes are given the same child.
.PP
Be aware that the \f[I]od\f[] (maximum outdegree) has a lot of influence
on the graph structure (way more than \f[I]id\f[] (maximum indegree).
.RE
.IP \[bu] 2
\f[C]ggen_generate_random_orders()\f[]
.RS 2
.PP
Generates a DAG having \f[I]n\f[] nodes and which partial order is the
intersection of \f[I]orders\f[] total orders.
.PP
Graph theory tells us that a DAG is a partial order.
A partial order can be generated by intersecting any number of randomly
generated total orders.
This is exactly what this function does.
.RE
.SS Analysis Functions
.IP \[bu] 2
\f[C]ggen_analyze_longest_path()\f[]
.RS 2
.PP
Computes the longest path in \f[I]g\f[].
Returns it as a vector containing the nodes of the path in order.
.RE
.IP \[bu] 2
\f[C]ggen_analyze_longest_antichain()\f[]
.RS 2
.PP
Computes the longest antichain of g.
Returns it as a vector containing the nodes of the chain (no specific
order).
.RE
.IP \[bu] 2
\f[C]ggen_analyze_lowest_single_ancestor()\f[]
.RS 2
.PP
Computes the lowest single ancestor of all vertices of g.
Returns it as vector, where v(i) is the lsa of vertex id i (in igraph).
.RE
.SS Tranformation Functions
.PP
Transformation functions have a \f[I]type\f[] parameter: \f[I]t\f[].
This parameter change the goal of the transformations.
.IP \[bu] 2
\f[C]ggen_transform_add()\f[]
.RS 2
.PP
Either a single source to the DAG \f[I]g\f[] or a single sink.
.RE
.IP \[bu] 2
\f[C]ggen_transform_delete()\f[]
.RS 2
.PP
Either delete all sources of the DAG \f[I]g\f[] or all sinks.
.RE
.SH NOTES
.PP
Functions returning a \f[C]igraph_t\ *\f[] should call
\f[C]igraph_destroy\f[] before \f[C]free\f[]ing the pointer.
.PP
You are responsible for the quality of the random number generator given
to the generation functions.
Be aware that the default RNG used by the GSL might not be appropriate.
.SH BUGS
.PP
No known bugs.
.SH REPORTING BUGS
.PP
If you find any bug or have any comment on this library, contact the
main developer directly: Swann Perarnau (swann.perarnau@imag.fr).
.SH COPYRIGHT
.PP
Copyright (C) 2009\-2011 Swann Perarnau and others.
License CeCILL: Open Source, GPL Compatible <http://www.cecill.info>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH SEE ALSO
.PP
This tool was presented in a full article at the
Simutools (http://www.simutools.org/2010/) Conference in March 2010.
You can find a copy of this article on the GGen
website (http://ggen.ligforge.imag.fr).
.SH AUTHORS
Swann Perarnau.
